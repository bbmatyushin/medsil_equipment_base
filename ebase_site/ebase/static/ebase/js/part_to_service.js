// Django Admin Spare Parts Dynamic Manager
// Generated by Claude AI
class SparePartsManager {
    constructor() {
        this.sparePartSelect = null;
        this.customBlock = null;
        this.originalQuantities = new Map(); // Хранит оригинальные количества при загрузке
        this.currentQuantities = new Map(); // Текущие введенные количества
        this.sparePartsData = new Map(); // Данные о запчастях (название, количество)
        this.isUpdating = false; // Флаг для предотвращения множественных обновлений

        this.init();
    }

    init() {
        // Ждем загрузки DOM
        if (document.readyState === 'loading') {
              window.addEventListener('load', () => this.setup())
//            document.addEventListener('DOMContentLoaded', () => this.setup());
        } else {
            this.setup();
        }
    }

    async setup() {
        this.sparePartSelect = document.getElementById('id_spare_part_to');

        if (!this.sparePartSelect) {
            console.warn('Spare part select element not found');
            return;
        }

        this.createCustomBlock();
        await this.loadInitialData();
        this.setupEventListeners();
        await this.updateCustomBlock();
    }

    createCustomBlock() {
        const sparePartRow = document.querySelector('.form-row.field-spare_part');
        if (!sparePartRow) {
            console.error('Spare part form row not found');
            return;
        }

        // Создаем контейнер для кастомного блока
        this.customBlock = document.createElement('div');
        this.customBlock.className = 'form-row custom-choice-spare_part';
        this.customBlock.innerHTML = `
            <div>
                <label>Выбранные запчасти:</label>
                <div id="selected-spare-parts" style="border: 1px solid #ccc; padding: 10px; margin-top: 5px; background: #f9f9f9;">
                    <div class="spare-parts-list"></div>
                </div>
            </div>
        `;

        // Вставляем после блока запчастей
        sparePartRow.parentNode.insertBefore(this.customBlock, sparePartRow.nextSibling);
    }

    async loadInitialData() {
        console.log('Loading initial data...');

        // Загружаем изначальные выбранные запчасти
        const selectedOptions = this.sparePartSelect.querySelectorAll('option');
        console.log(`Found ${selectedOptions.length} options in select`);

        for (let option of selectedOptions) {
            if (option.value && option.value.trim() !== '') {
                console.log(`Loading data for spare part: ${option.value}`);

                // Получаем данные о запчасти с сервера
                const sparePartData = await this.getSparePartData(option.value);
                if (sparePartData) {
                    this.sparePartsData.set(option.value, sparePartData);

                    // Если это существующая запись, пытаемся получить исходное количество
                    // В реальном проекте это значение нужно получать с сервера или из data-атрибутов
                    const existingQuantity = this.getExistingQuantity(option.value);
                    this.originalQuantities.set(option.value, existingQuantity);
                    this.currentQuantities.set(option.value, existingQuantity);

                    console.log(`Loaded spare part: ${sparePartData.name}, available: ${sparePartData.quantity}, existing: ${existingQuantity}`);
                }
            }
        }

        console.log(`Loaded ${this.sparePartsData.size} spare parts`);
    }

    getExistingQuantity(sparePartId) {
        // Попытка получить существующее количество из data-атрибутов или других источников
        // В реальном проекте это может быть получено с сервера или из скрытых полей формы

        // Ищем в скрытых полях формы
        const hiddenFields = document.querySelectorAll('input[name^="spare_part_quantities"]');
        for (let field of hiddenFields) {
            try {
                const data = JSON.parse(field.value);
                if (data.id === sparePartId) {
                    return data.quantity || 0;
                }
            } catch (e) {
                continue;
            }
        }

        // Можно также попробовать получить из data-атрибута option
        const option = this.sparePartSelect.querySelector(`option[value="${sparePartId}"]`);
        if (option && option.dataset.quantity) {
            return parseInt(option.dataset.quantity) || 0;
        }

        return 0; // По умолчанию
    }

    setupEventListeners() {
        // Отслеживаем изменения в select
        const observer = new MutationObserver((mutations) => {
            if (this.isUpdating) return; // Предотвращаем множественные обновления

            let hasChanges = false;
            mutations.forEach((mutation) => {
                if (mutation.type === 'childList') {
                    hasChanges = true;
                }
            });

            if (hasChanges) {
                console.log('Select changed, updating...');
                this.handleSelectChange();
            }
        });

        observer.observe(this.sparePartSelect, {
            childList: true,
            subtree: true
        });

        // Также отслеживаем прямые изменения в select (для случаев когда MutationObserver может не сработать)
        this.sparePartSelect.addEventListener('change', () => {
            if (!this.isUpdating) {
                console.log('Select change event triggered');
                setTimeout(() => this.handleSelectChange(), 100);
            }
        });

        // Обработчик для формы сохранения
        const form = document.querySelector('form');
        if (form) {
//            form.addEventListener('submit', (e) => this.handleFormSubmit(e));
              form.addEventListener('submit', async (e) => {
                e.preventDefault();
                const ok = await this.handleFormSubmit(e);
                if (ok) {
                     e.target.submit();; // теперь сабмит произойдёт уже с добавленными hidden-полями
                }
              });

              // Также добавляем обработчик на кнопки submit
            const submitButtons = document.querySelectorAll('.submit-row input[type="submit"]');
            submitButtons.forEach((button, btnIndex) => {
                console.log(`Adding click listener to submit button ${btnIndex}:`, button);
                button.addEventListener('click', async (e) => this.handleFormSubmit(e));

//                button.addEventListener('click', (e) => {
//                    e.preventDefault(); // стопим стандартный сабмит
//                    const hidden = document.createElement('input');
//                    hidden.type = 'hidden';
//                    hidden.name = button.name;
//                    hidden.value = button.value;
//                    form.appendChild(hidden);
//                    console.log('Submit button clicked:', button);
//                    // Даем небольшую задержку чтобы форма успела сработать
//                    setTimeout(() => {
//                        const submitEvent = new Event('submit', { bubbles: true, cancelable: true });
//                        form.dispatchEvent(submitEvent)
//                        if (form.dispatchEvent(submitEvent)) {
//                              form.submit(); // Ручная отправка
////                            boundHandler(submitEvent);
//                        }
//                    }, 10);
//                });
            });


        }
    }

    async handleSelectChange() {
        if (this.isUpdating) {
            console.log('Already updating, skipping...');
            return;
        }

        console.log('Handling select change...');
        this.isUpdating = true;

        // Получаем текущие ID из select
        const currentIds = new Set();
        const selectedOptions = this.sparePartSelect.querySelectorAll('option');

        console.log(`Found ${selectedOptions.length} options in select`);

        for (let option of selectedOptions) {
            if (option.value && option.value.trim() !== '') {
                currentIds.add(option.value);

                // Если это новая запчасть, получаем её данные
                if (!this.sparePartsData.has(option.value)) {
                    console.log(`Loading new spare part: ${option.value}`);
                    const sparePartData = await this.getSparePartData(option.value);
                    if (sparePartData) {
                        this.sparePartsData.set(option.value, sparePartData);
                        this.originalQuantities.set(option.value, 0);
                        this.currentQuantities.set(option.value, 0);
                    }
                }
            }
        }

        // Удаляем данные о запчастях, которых больше нет в select
        const toRemove = [];
        this.sparePartsData.forEach((data, id) => {
            if (!currentIds.has(id)) {
                console.log(`Removing spare part: ${id}`);
                toRemove.push(id);
            }
        });

        toRemove.forEach(id => {
            this.sparePartsData.delete(id);
            this.originalQuantities.delete(id);
            this.currentQuantities.delete(id);
        });

        console.log(`Current spare parts count: ${this.sparePartsData.size}`);

        // Обновляем отображение
        await this.updateCustomBlock();

        this.isUpdating = false;
        console.log('Select change handled');
    }

    async updateCustomBlock() {
        console.log('Updating custom block...');
        const container = this.customBlock.querySelector('.spare-parts-list');
        if (!container) {
            console.error('Container not found');
            return;
        }

        // Очищаем контейнер
        container.innerHTML = '';

        console.log(`Creating rows for ${this.sparePartsData.size} spare parts`);

        // Создаем строки для каждой запчасти
        for (let [sparePartId, sparePartData] of this.sparePartsData) {
            console.log(`Creating row for: ${sparePartData.name}`);
            await this.createSparePartRow(container, sparePartId, sparePartData);
        }

        console.log('Custom block updated');
    }

    async createSparePartRow(container, sparePartId, sparePartData) {
        const currentQty = this.currentQuantities.get(sparePartId) || 0;
        const originalQty = this.originalQuantities.get(sparePartId) || 0;
        const availableQty = sparePartData.quantity || 0;

        // Рассчитываем максимально допустимое количество для ввода
        const maxAllowed = availableQty + originalQty;

        const row = document.createElement('div');
        row.className = 'spare-part-row';
        row.setAttribute('data-spare-part-id', sparePartId);
        row.style.cssText = `
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
        `;

        row.innerHTML = `
            <div style="flex: 1; margin-right: 10px;">
                <strong>${sparePartData.name}</strong>
            </div>
            <div style="margin-right: 10px;">
                Доступно: <span class="available-qty">${Math.max(0, availableQty - currentQty + originalQty)}</span> шт.
            </div>
            <div style="margin-right: 10px;">
                <label for="qty-${sparePartId}">Количество:</label>
                <input
                    type="number"
                    id="qty-${sparePartId}"
                    value="${currentQty}"
                    min="0"
                    max="${maxAllowed}"
                    style="width: 80px; margin-left: 5px;"
                    data-spare-part-id="${sparePartId}"
                >
            </div>`;

        container.appendChild(row);

        // Обработчики событий для этой строки
        const qtyInput = row.querySelector(`#qty-${sparePartId}`);

        qtyInput.addEventListener('change', (e) => {
            const newQty = parseInt(e.target.value) || 0;
            this.currentQuantities.set(sparePartId, newQty);
            this.updateAvailableDisplay(sparePartId);
        });

        qtyInput.addEventListener('input', (e) => {
            const newQty = parseInt(e.target.value) || 0;
            this.currentQuantities.set(sparePartId, newQty);
            this.updateAvailableDisplay(sparePartId);
        });
    }

    updateAvailableDisplay(sparePartId) {
        const row = this.customBlock.querySelector(`[data-spare-part-id="${sparePartId}"]`);
        if (!row) return;

        const availableSpan = row.querySelector('.available-qty');
        const sparePartData = this.sparePartsData.get(sparePartId);
        const currentQty = this.currentQuantities.get(sparePartId) || 0;
        const originalQty = this.originalQuantities.get(sparePartId) || 0;

        if (sparePartData) {
            const originalAvailable = sparePartData.quantity || 0;
            const displayAvailable = originalAvailable - currentQty + originalQty;
            availableSpan.textContent = Math.max(0, displayAvailable);

            // Обновляем максимальное значение в input
            const qtyInput = row.querySelector(`#qty-${sparePartId}`);
            qtyInput.max = originalAvailable + originalQty;
        }
    }

    async getSparePartData(sparePartId) {
        console.log(`Fetching data for spare part: ${sparePartId}`);
        try {
            const response = await fetch(`/admin/get-spare-part-quantity/${sparePartId}/`, {
                method: 'GET',
                headers: {
                    'X-CSRFToken': this.getCSRFToken(),
                    'Content-Type': 'application/json',
                },
            });

            if (response.ok) {
                const data = await response.json();
                console.log(`Received data:`, data);
                return {
                    name: data.name || 'Неизвестная запчасть',
                    quantity: data.quantity || 0,
                    id: data.spare_part_id || sparePartId
                };
            } else {
                console.error(`Failed to fetch data for ${sparePartId}: ${response.status}`);
            }
        } catch (error) {
            console.error('Error fetching spare part data:', error);
        }

        // Fallback - возвращаем данные с placeholder названием
        console.log(`Using fallback data for: ${sparePartId}`);
        return {
            name: `Запчасть c ID: ${sparePartId} не найдена`,
            quantity: 0,  // Math.floor(Math.random() * 50) + 1,
            id: sparePartId
        };
    }

    async handleFormSubmit(e) {
        // Подготавливаем данные для отправки
        const sparePartsData = [];

        console.log('>>>>>>>>>>>>>>>>>>>>>>>>');
        console.log(this.currentQuantities);
        console.log('>>>>>>>>>>>>>>>>>>>>>>>>');

        this.currentQuantities.forEach((quantity, sparePartId) => {
            if (quantity > 0) {
                sparePartsData.push({
                    id: sparePartId,
                    quantity: quantity,
                    originalQuantity: this.originalQuantities.get(sparePartId) || 0
                });
            }
        });

        // Добавляем скрытые поля в форму для передачи данных
        const form = e.target || e.target.form;

        // Удаляем предыдущие скрытые поля, если есть
//        const existingFields = form.querySelectorAll('input[name^="spare_part_quantities"]');
//        existingFields.forEach(field => field.remove());

        // Добавляем новые скрытые поля
        sparePartsData.forEach((item, index) => {
            const hiddenField = document.createElement('input');
            hiddenField.type = 'hidden';
            hiddenField.name = `spare_part_quantities[${index}]`;
            hiddenField.value = JSON.stringify(item);
            form.appendChild(hiddenField);
        });

        // Валидация количеств
        const isValid = this.validateQuantities();
        if (!isValid) {
            e.preventDefault();
            alert('Проверьте количества запчастей. Некоторые значения превышают доступное количество.');
            return false;
        }

        return true;
    }

    validateQuantities() {
        for (let [sparePartId, currentQty] of this.currentQuantities) {
            const sparePartData = this.sparePartsData.get(sparePartId);
            const originalQty = this.originalQuantities.get(sparePartId) || 0;

            if (sparePartData) {
                const availableQty = sparePartData.quantity || 0;
                const maxAllowed = availableQty + originalQty;

                if (currentQty > maxAllowed) {
                    console.error(`Spare part ${sparePartId}: ${currentQty} > ${maxAllowed}`);
                    return false;
                }
            }
        }
        return true;
    }

    getCSRFToken() {
        const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
        return csrfToken ? csrfToken.value : '';
    }
}

// Инициализация при загрузке страницы
new SparePartsManager();